# ksh26 build system

## Architecture

Three tools, each doing one thing:

```
just build
  → bootstrap samu     (cc -o build/$HOSTTYPE/bin/samu src/cmd/INIT/samu/*.c)
  → run configure.ksh  (probes → build.ninja)
  → samu -C build/$HOSTTYPE
```

| Layer | Tool | What it does |
|-------|------|--------------|
| Porcelain | `just` | User-facing recipes: `build`, `test`, `clean`, `install` |
| Configure | `configure.ksh` | Probes platform, detects features, generates `build.ninja` |
| Build engine | `samu` | Executes `build.ninja` — fast, parallel, depfile-aware |

`samu` is a vendored C implementation of ninja (ISC/Apache-2.0/MIT licensed,
from michaelforney/samurai). It compiles in under a second with a plain `cc`
invocation, giving us a zero-dependency bootstrap.

## Directory layout

```
ksh26-build/
├── justfile                        # porcelain (~47 lines)
├── configure.ksh                   # probes + generates build.ninja (~1000 lines)
├── BUILD.md                        # this file
├── src/
│   ├── cmd/
│   │   ├── INIT/
│   │   │   ├── samu/              # vendored samurai source
│   │   │   ├── iffe.sh            # "if feature exists" probe tool (kept as-is)
│   │   │   ├── mamprobe.sh        # compiler capability detection (kept as-is)
│   │   │   ├── C+probe            # compiler probe preamble
│   │   │   └── make.probe         # make probe preamble
│   │   └── ksh26/                 # shell source (unchanged)
│   └── lib/
│       ├── libast/                # AST library source (unchanged)
│       ├── libcmd/                # command library source (unchanged)
│       ├── libdll/                # dynamic linking library source (unchanged)
│       └── libsum/                # checksum library source (unchanged)
└── build/                         # all generated output (gitignored)
    └── $HOSTTYPE/                 # e.g., darwin.arm64-64
        ├── bin/
        │   ├── samu               # bootstrapped build tool
        │   ├── ksh                # the built shell
        │   └── shcomp             # shell compiler
        ├── build.ninja            # generated by configure.ksh
        ├── config.probe           # cached mamprobe output
        ├── include/
        │   ├── ast/               # generated AST headers (FEATURE/*, ast_*.h)
        │   ├── std/               # AST stdio/wchar wrapper headers
        │   ├── conftab.h          # generated conf tables
        │   ├── lc.h               # generated locale tables
        │   ├── conftab.c          # generated (compiled into libast)
        │   └── lctab.c            # generated (compiled into libast)
        ├── lib/
        │   ├── libast.a           # AST base library
        │   ├── libsum.a           # checksum library
        │   ├── libdll.a           # dynamic linking library
        │   ├── libcmd.a           # command library
        │   └── libshell.a         # shell library
        ├── obj/                   # .o files + .d depfiles
        │   ├── libast/
        │   ├── libsum/
        │   ├── libdll/
        │   ├── libcmd/
        │   └── ksh26/
        ├── libast_work/           # iffe working directory for libast
        ├── libsum_work/           # iffe working directory for libsum
        ├── libdll_work/           # iffe working directory for libdll
        ├── libcmd_work/           # iffe working directory for libcmd
        │   ├── cmdext.h           # generated command prototypes
        │   └── cmdlist.h          # generated command list macros
        ├── ksh26_work/            # iffe working directory for ksh26
        │   ├── FEATURE/           # ksh26-specific feature headers
        │   ├── shopt.h            # generated compile-time options
        │   └── git.h              # generated git commit hash
        └── probe/                 # mamprobe infrastructure
```

## How configure.ksh works

configure.ksh is a single-pass script that runs entirely before compilation.
It does five things:

### 1. Probe the compiler

Uses `mamprobe.sh` (the existing AT&T compiler detection tool) to discover
compiler flags, AR path, optimization flags, etc. Output is parsed from
mamprobe's `setv mam_cc_FOO value` format into shell variables.

### 2. Run iffe feature tests

`iffe.sh` ("if feature exists") is the AT&T feature probe tool. It compiles
small test programs to detect platform capabilities: which headers exist,
which functions are available, struct layouts, etc.

Feature tests run for each library in dependency order:
1. **libast** (~40 tests) — standards, common, lib, map, then the rest
2. **libsum** (1 test) — sum
3. **libdll** (1 test) — dll
4. **libcmd** (4 tests) — symlink, sockets, ids, utsname
5. **ksh26** (9 tests) — math, time, options, fchdir, locale, cmds, poll, rlimits, externs

Each test produces a `FEATURE/<name>` header with `#define`s for detected
capabilities.

**Standalone C probes**: Three ksh26 tests (externs, options, fchdir) originally
used AST library functions in their `output{}` blocks — not because they needed
AST, but because it was the environment available during the old staged build.
We probe those values with standalone C programs instead, removing the circular
dependency on libast and allowing all probing to happen before compilation.

### 3. Generate derived headers

- **shopt.h** — compile-time shell options, from `SHOPT.sh` + runtime probes
  (e.g., `/dev/fd` availability, `test -l` support)
- **git.h** — embedded git commit hash
- **cmdext.h / cmdlist.h** — command function prototypes and list macros,
  generated by scanning `b_*` function signatures in libcmd source files
- **conftab.h / conftab.c** — POSIX conf tables, from `conf.tab` + `conf.sh`
- **lc.h / lctab.c** — locale tables, from `lc.tab` via `lcgen`

### 4. Install public headers

Copies source headers from `src/lib/libast/include/` and `src/lib/libast/std/`
into the build include directory so all compilation targets can find them.

### 5. Emit build.ninja

Generates a ninja build file with three rule types:

```ninja
rule cc       # compile .c → .o with automatic depfile tracking
rule ar       # archive .o files → .a
rule link     # link .o + .a → executable
```

All source and include paths are absolute. All output paths (obj/, lib/, bin/)
are relative to the build directory, because samu runs with `-C build/$HOSTTYPE`.

Ninja's depfile mechanism (`-MD -MF $out.d`) automatically tracks which headers
each .c file includes. No manual header dependency declarations needed — first
build compiles everything, incremental builds recompile only what changed.

## Library dependency graph

```
ksh (bin/ksh)
└── libshell.a (64 .c files from ksh26/)
    ├── libcmd.a (48 .c files)
    │   └── libsum.a (1 compiled unit)
    ├── libast.a (~444 .c files)
    └── libdll.a (10 .c files)
```

Link order: `-lshell -lcmd -last -ldll -lsum -lm`

## AST stdio redirection (important coupling point)

AST replaces the C standard library's `FILE` type with its own `Sfio_t`
(from the sfio "safe/fast IO" library). This is implemented via:

1. `FEATURE/stdio` header — `#define FILE _sfio_FILE` plus `#define fopen _ast_fopen`, etc.
2. `std/` wrapper headers — `std/stdio.h`, `std/wchar.h` that `#include` AST equivalents

For this to work, `build/$HOSTTYPE/include/std/` must appear on the include
path *before* system headers, so `#include <stdio.h>` finds AST's wrapper
instead of the system's. This is the `ast_std` include flag in the build.

**For libast itself**: The source tree's `src/lib/libast/std/` directory is
included via the subdirectory loop, so it picks up wrappers from source.

**For everything else**: The installed copies at `build/$HOSTTYPE/include/std/`
are used, via the `$ast_std` cflags variable.

This is the single biggest coupling point in the codebase. If libast's IO
layer is replaced with standard stdio, this entire wrapper mechanism goes away
and the build simplifies significantly.

## macOS-specific concerns

**Case-insensitive filesystem**: APFS (default on macOS) is case-insensitive,
which means `FEATURE/locale` and `features/locale` (the iffe *input* directory)
collide. The build handles this by excluding `features/` from libast's
subdirectory include path.

**ksh26 vs libast FEATURE namespace**: Both produce `FEATURE/locale` and
`FEATURE/time` with different content. ksh26's copies stay in `ksh26_work/`
and are found via `-I$BUILDDIR/ksh26_work`. They are NOT copied to the shared
`FEATDIR`.

## Environment variable interface

| Variable | Default | Effect |
|----------|---------|--------|
| `CC` | `cc` | C compiler |
| `CFLAGS` | (from mamprobe) | Compiler flags (merged with probe results) |
| `HOSTTYPE` | (from `bin/package host type`) | Target platform identifier |
| `PACKAGEROOT` | (script directory) | Source tree root |

These are the integration points for nix, cross-compilation, CI, etc. A nix
flake can set `CC`, `CFLAGS`, and `HOSTTYPE` to control the build without
touching configure.ksh.

## Build phases (for nix integration)

The build has clean separable phases suitable for nix's `stdenv.mkDerivation`:

1. **bootstrap** — compile samu from vendored C source (pure, no network)
2. **configure** — run configure.ksh (probes compiler, runs feature tests)
3. **build** — samu executes build.ninja (parallel compilation)
4. **check** — run test suite
5. **install** — copy binaries to prefix

Each phase depends only on the previous phase's outputs. Configure is the only
phase that runs test programs (feature probes), which matters for
cross-compilation: you'd need to provide pre-computed feature results or use
qemu.

## Retained tools from the old build system

| Tool | Why kept |
|------|----------|
| `iffe.sh` | 98KB battle-tested feature prober, works on dozens of platforms. Rewriting probes would be high risk, low reward. |
| `mamprobe.sh` | Compiler capability detection. Outputs structured data we parse. |
| `C+probe`, `make.probe` | Probe preambles that mamprobe.sh needs. |
| `bin/package` | Used only for `host type` (HOSTTYPE detection). Could be inlined later. |
| `bin/shtests` | Test runner. Unchanged. |

## Replaced components

| Old | New | Lines removed |
|-----|-----|---------------|
| `Mamfile` (per-library, ~6000 lines total) | `configure.ksh` (~1000 lines) + `build.ninja` (generated) | ~6000 |
| `mamake.c` (MAM interpreter) | `samu` (vendored ninja) | ~3000 |
| `bin/package` (build orchestrator) | `justfile` (~47 lines) | ~3000 |

## Adding or removing a library

To add a new library `libfoo`:

1. Add `collect_libfoo_sources()` function to configure.ksh
2. Add feature test function if needed (`run_libfoo_features`)
3. Add a ninja section in `emit_ninja()` (cflags, object loop, archive target)
4. Add to ksh's link line if needed

To remove a library (e.g., replacing libsum with a system library):

1. Remove its `collect_*`, `run_*_features`, and `emit_ninja` section
2. Replace the archive reference in the link line with `-lfoo` or pkg-config flags
3. Remove any generated headers it provided

The build is structured so each library is a self-contained section in both
configure.ksh and the generated build.ninja.
