# ksh26 build system

## Architecture

Three tools, each doing one thing:

```
just build
  → bootstrap samu     (cc -o build/$HOSTTYPE/bin/samu src/cmd/INIT/samu/*.c)
  → run configure.sh  (probes → build.ninja)
  → samu -C build/$HOSTTYPE
```

| Layer | Tool | What it does |
|-------|------|--------------|
| Porcelain | `just` | User-facing recipes: `build`, `test`, `clean`, `install` |
| Configure | `configure.sh` | Probes platform, detects features, generates `build.ninja` |
| Build engine | `samu` | Executes `build.ninja` — fast, parallel, depfile-aware |

`samu` is a vendored C implementation of ninja (ISC/Apache-2.0/MIT licensed,
from michaelforney/samurai). It compiles in under a second with a plain `cc`
invocation, giving us a zero-dependency bootstrap.

## Directory layout

```
ksh26-build/
├── justfile                        # porcelain (~47 lines)
├── configure.sh                   # probes + generates build.ninja (~1600 lines)
├── BUILD.md                        # this file
├── src/
│   ├── cmd/
│   │   ├── INIT/
│   │   │   ├── samu/              # vendored samurai source
│   │   │   ├── iffe.sh            # "if feature exists" probe tool (kept as-is)
│   │   │   ├── mamprobe.sh        # compiler capability detection
│   │   │   ├── C+probe            # compiler probe preamble
│   │   │   └── make.probe         # make probe preamble
│   │   └── ksh26/                 # shell source (unchanged)
│   └── lib/
│       ├── libast/                # AST library source (unchanged)
│       ├── libcmd/                # command library source (unchanged)
│       ├── libdll/                # dynamic linking library source (unchanged)
│       └── libsum/                # checksum library source (unchanged)
└── build/                         # all generated output (gitignored)
    └── $HOSTTYPE/                 # e.g., darwin.arm64-64
        ├── bin/
        │   ├── samu               # bootstrapped build tool
        │   ├── ksh                # the built shell
        │   └── shcomp             # shell compiler
        ├── build.ninja            # generated by configure.sh
        ├── config.probe           # cached compiler probe output
        ├── include/
        │   ├── ast/               # generated AST headers (FEATURE/*, ast_*.h)
        │   ├── std/               # AST stdio/wchar wrapper headers
        │   ├── conftab.h          # generated conf tables
        │   ├── lc.h               # generated locale tables
        │   ├── conftab.c          # generated (compiled into libast)
        │   └── lctab.c            # generated (compiled into libast)
        ├── lib/
        │   ├── libast.a           # AST base library
        │   ├── libsum.a           # checksum library
        │   ├── libdll.a           # dynamic linking library
        │   ├── libcmd.a           # command library
        │   └── libshell.a         # shell library
        ├── obj/                   # .o files + .d depfiles
        │   ├── libast/
        │   ├── libsum/
        │   ├── libdll/
        │   ├── libcmd/
        │   └── ksh26/
        ├── libast_work/           # iffe working directory for libast
        ├── libsum_work/           # iffe working directory for libsum
        ├── libdll_work/           # iffe working directory for libdll
        ├── libcmd_work/           # iffe working directory for libcmd
        │   ├── cmdext.h           # generated command prototypes
        │   └── cmdlist.h          # generated command list macros
        ├── ksh26_work/            # iffe working directory for ksh26
        │   ├── FEATURE/           # ksh26-specific feature headers
        │   ├── shopt.h            # generated compile-time options
        │   └── git.h              # generated git commit hash
        └── probe/                 # compiler probe infrastructure
```

## How configure.sh works

configure.sh is a single-pass script that runs entirely before compilation.
It does five things:

### 1. Probe the compiler

Uses `mamprobe.sh` (AT&T's compiler detection tool, retained from ksh93u+m)
to discover compiler flags, AR path, optimization flags, etc. Output is
parsed from mamprobe's `setv mam_cc_FOO value` format into shell variables.

### 2. Run iffe feature tests

`iffe.sh` ("if feature exists") is the AT&T feature probe tool. It compiles
small test programs to detect platform capabilities: which headers exist,
which functions are available, struct layouts, etc.

Feature tests run for each library in dependency order:
1. **libast** (~40 tests) — standards, common, lib, map, then the rest
2. **libsum** (1 test) — sum
3. **libdll** (1 test) — dll
4. **libcmd** (4 tests) — symlink, sockets, ids, utsname
5. **ksh26** (9 tests) — math, time, options, fchdir, locale, cmds, poll, rlimits, externs

Each test produces a `FEATURE/<name>` header with `#define`s for detected
capabilities.

**Standalone C probes**: Three ksh26 tests (externs, options, fchdir) originally
used AST library functions in their `output{}` blocks — not because they needed
AST, but because it was the environment available during the old staged build.
We probe those values with standalone C programs instead, removing the circular
dependency on libast and allowing all probing to happen before compilation.

### 3. Generate derived headers

- **shopt.h** — compile-time shell options, from `SHOPT.sh` + runtime probes
  (e.g., `/dev/fd` availability, `test -l` support)
- **git.h** — embedded git commit hash
- **cmdext.h / cmdlist.h** — command function prototypes and list macros,
  generated by scanning `b_*` function signatures in libcmd source files
- **conftab.h / conftab.c** — POSIX conf tables, from `conf.tab` + `conf.sh`
- **lc.h / lctab.c** — locale tables, from `lc.tab` via `lcgen`

### 4. Install public headers

Copies source headers from `src/lib/libast/include/` and `src/lib/libast/std/`
into the build include directory so all compilation targets can find them.

### 5. Emit build.ninja

Generates a ninja build file with three rule types:

```ninja
rule cc       # compile .c → .o with automatic depfile tracking
rule ar       # archive .o files → .a
rule link     # link .o + .a → executable
```

All source and include paths are absolute. All output paths (obj/, lib/, bin/)
are relative to the build directory, because samu runs with `-C build/$HOSTTYPE`.

Ninja's depfile mechanism (`-MD -MF $out.d`) automatically tracks which headers
each .c file includes. No manual header dependency declarations needed — first
build compiles everything, incremental builds recompile only what changed.

## Library dependency graph

```
ksh (bin/ksh)
└── libshell.a (64 .c files from ksh26/)
    ├── libcmd.a (48 .c files)
    │   └── libsum.a (1 compiled unit)
    ├── libast.a (~444 .c files)
    └── libdll.a (10 .c files)
```

Link order: `-lshell -lcmd -last -ldll -lsum -lm`

## AST stdio redirection (important coupling point)

AST replaces the C standard library's `FILE` type with its own `Sfio_t`
(from the sfio "safe/fast IO" library). This is implemented via:

1. `FEATURE/stdio` header — `#define FILE _sfio_FILE` plus `#define fopen _ast_fopen`, etc.
2. `std/` wrapper headers — `std/stdio.h`, `std/wchar.h` that `#include` AST equivalents

For this to work, `build/$HOSTTYPE/include/std/` must appear on the include
path *before* system headers, so `#include <stdio.h>` finds AST's wrapper
instead of the system's. This is the `ast_std` include flag in the build.

**For libast itself**: The source tree's `src/lib/libast/std/` directory is
included via the subdirectory loop, so it picks up wrappers from source.

**For everything else**: The installed copies at `build/$HOSTTYPE/include/std/`
are used, via the `$ast_std` cflags variable.

This is the single biggest coupling point in the codebase. If libast's IO
layer is replaced with standard stdio, this entire wrapper mechanism goes away
and the build simplifies significantly.

## macOS-specific concerns

**Case-insensitive filesystem**: APFS (default on macOS) is case-insensitive,
which means `FEATURE/locale` and `features/locale` (the iffe *input* directory)
collide. The build handles this by excluding `features/` from libast's
subdirectory include path.

**ksh26 vs libast FEATURE namespace**: Both produce `FEATURE/locale` and
`FEATURE/time` with different content. ksh26's copies stay in `ksh26_work/`
and are found via `-I$BUILDDIR/ksh26_work`. They are NOT copied to the shared
`FEATDIR`.

## Environment variable interface

| Variable | Default | Effect |
|----------|---------|--------|
| `CC` | `cc` | C compiler |
| `CFLAGS` | (from compiler probe) | Compiler flags (merged with probe results) |
| `HOSTTYPE` | (auto-detected) | Target platform identifier (`os.arch-bits`, e.g. `darwin.arm64-64`) |
| `PACKAGEROOT` | (script directory) | Source tree root |

These are the integration points for nix, cross-compilation, CI, etc. A nix
flake can set `CC`, `CFLAGS`, and `HOSTTYPE` to control the build without
touching configure.sh.

## Build phases (for nix integration)

The build has clean separable phases suitable for nix's `stdenv.mkDerivation`:

1. **bootstrap** — compile samu from vendored C source (pure, no network)
2. **configure** — run configure.sh (probes compiler, runs feature tests)
3. **build** — samu executes build.ninja (parallel compilation)
4. **check** — run test suite
5. **install** — copy binaries to prefix

Each phase depends only on the previous phase's outputs. Configure is the only
phase that runs test programs (feature probes), which matters for
cross-compilation: you'd need to provide pre-computed feature results or use
qemu.

## Retained upstream tools

Two tools from the original AT&T build infrastructure are still used for
platform probing. The rest (Mamfiles, mamake, bin/package) is retired.

| Tool | Role |
|------|------|
| `iffe.sh` | "If feature exists" — 98KB battle-tested feature prober. Compiles small test programs to detect platform capabilities. |
| `mamprobe.sh` | Compiler capability detection. Discovers flags, AR path, shared library conventions. |
| `C+probe`, `make.probe` | Probe preambles that mamprobe.sh needs. |
| `bin/shtests` | Test harness for serial test runs (`just test-serial`). |

## Adding or removing a library

To add a new library `libfoo`:

1. Add `collect_libfoo_sources()` function to configure.sh
2. Add feature test function if needed (`run_libfoo_features`)
3. Add a ninja section in `emit_ninja()` (cflags, object loop, archive target)
4. Add to ksh's link line if needed

To remove a library (e.g., replacing libsum with a system library):

1. Remove its `collect_*`, `run_*_features`, and `emit_ninja` section
2. Replace the archive reference in the link line with `-lfoo` or pkg-config flags
3. Remove any generated headers it provided

The build is structured so each library is a self-contained section in both
configure.sh and the generated build.ninja.
